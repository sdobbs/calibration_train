## Hi
## Author: Sean Dobbs (s-dobbs@northwestern.edu)

import os,sys
from ROOT import TFile,TTree
import rcdb
from optparse import OptionParser
from array import array
import pprint
import datetime
import ConfigParser

import ccdb
from ccdb import Directory, TypeTable, Assignment, ConstantSet

def LoadCCDB():
    sqlite_connect_str = "mysql://ccdb_user@hallddb.jlab.org/ccdb"
    #sqlite_connect_str = "sqlite:////scratch/gxproj3/ccdb.sqlite"
    #sqlite_connect_str = "sqlite:////group/halld/www/halldweb/html/dist/ccdb.sqlite"
    provider = ccdb.AlchemyProvider()                        # this class has all CCDB manipulation functions
    provider.connect(sqlite_connect_str)                     # use usual connection string to connect to database
    #provider.authentication.current_user_name = "gxproj3"    # to have a name in logs
    provider.authentication.current_user_name = "hdsys"    # to have a name in logs

    return provider


# assumes both are same table format
def check_out_of_tolerance(table1,table2,tolerance,verbose=0,masks=None):
    #pp = pprint.PrettyPrinter(indent=4)
    result = False
    modified_channels = []
    max_diff = 0
    # I hope these are all non-strings...
    for row in xrange(len(table1)):
        for col in xrange(len(table1[row])):
            #pp.pprint("check")
            #pp.pprint( (row,col) )
            #pp.pprint( masks )
            if masks is not None and (row,col) in masks:
                #print "skipping entry:  (%d,%d)"%(row,col)
                continue

            #print float(table1[row][col]),float(table2[row][col])
            diff = abs(float(table1[row][col])-float(table2[row][col]))
            if diff > tolerance:
                if diff > max_diff:
                    max_diff = diff
                    print "difference:  (",str(row),",",str(col),")  ",table1[row][col],"  ",table2[row][col]
                    modified_channels.append( ( (row,col), table1[row][col], table2[row][col] ) )
                result = True

    # we're all good
    if verbose>0 and result:
        print "max delta = ",max_diff
    return (result,modified_channels)

#--------------------------------------------------------
# MakeHEADER_HTML
#
# Return string with HTML for first part of log entry
#--------------------------------------------------------
def MakeHEADER_HTML(RUN,IS_DRY_RUN):
    items =[];
    items.append(['Time',datetime.datetime.now().strftime('%c')])

    html  = '<h2>Automated online calibration log entry for run '+ str(RUN) + '</h2>\n'
    html += '<p><font size="-1"><i>This entry generated by the script: $Id$</i></font></p>\n'
    if IS_DRY_RUN:
        html += '<h3>Running in test mode, new calibrations are only stored in "calib" CCDB variation, not pushed to default</h3>'

    html += '<center><hr width="80%"></center>\n'

    #html += '<table border="0">\n'
    #for (key,val) in items: html += '  <TR><TD align="right"><b>'+key+'</b></TD><TD>:</TD><TD>'+val+'</TD></TR>\n'
    #html += '</table>\n'
    
    return html

#--------------------------------------------------------
# MakeTOLERANCES_HTML
#--------------------------------------------------------
def MakeTOLERANCES_HTML(tolerance_table, color='black'):

    # Open HTML table
    html  = '<p>\n'
    html += '<b>' + "Tolerances" + '</b>\n'
    html += '<table><tr><td><div style="border:2px solid '+color+'; background-color:#CCC">\n' # This just gives a border around outside of table
    html += '<table border="0" bgcolor="#DDD" cellpadding="5" cellspacing="2">\n' # Actual table

    # Add a header
    html += '<TR> <TH>Table</TH><TH>Value (ns)</TH> </TR>'

    for table_name in sorted(tolerance_table.keys()):
        html += '  <TR>\n'
        html += '    <TD align="right"><font color="black">' + table_name  + '</font></TD>\n'
        html += '    <TD align="center"><font color="black">' + str(tolerance_table[table_name])  + '</font></TD>\n'
        html += '  </TR>\n'

    # Close HTML table
    html += '</table>\n'  # actual table
    html += '</div></td></tr></table>\n'  # Border around table
    html += '</p>\n'

    html += '<center><hr width="80%"></center>\n'

    return html

#--------------------------------------------------------
# MakeCCDBTABLE_HTML
#--------------------------------------------------------
def MakeCCDBTABLE_HTML(ccdb_table, modified_channels, color='black', ccdb=None, bgcolor="#DDD"):
    if ccdb is not None:
        table_info = ccdb.get_type_table(ccdb_table)

    # Open HTML table
    html  = '<p>\n'
    html += '<b>' + ccdb_table + '</b>\n'
    html += "<table><tr><td><div style=\"border:2px solid '+color+'; background-color:%s\">\n"%(bgcolor) # This just gives a border around outside of table
    html += "<table border=\"0\" bgcolor=\"%s\" cellpadding=\"5\" cellspacing=\"2\">\n"%(bgcolor) # Actual table

    # Add a header
    html += '<TR> <TH>Row,Column</TH><TH>Old Value</TH><TH>New Value</TH> </TR>\n'

    for ( (row,col),old_val,new_val ) in modified_channels:
        html += '  <TR>\n'
        if ccdb is None:
            html += '    <TD align="center><font color="black">' + str(row) + ', ' + str(col)  + '</font></TD>\n'
        else:
            html += "    <TD align=\"center\"><font color=\"black\">[%d] %s</font></TD>\n"%(row,table_info.columns[col].name)
        html += '    <TD align="center"><font color="black">' + str(old_val) + '</font></TD>\n'
        html += '    <TD align="center"><font color="black">' + str(new_val) + '</font></TD>\n'
        html += '  </TR>\n'

    # Close HTML table
    html += '</table>\n'  # actual table
    html += '</div></td></tr></table>\n'  # Border around table
    html += '</p>\n'

    return html


#--------------------------------------------------------
# HTMLBox
#
# Wrap the given text in an HTML box such that the text is
# marked as the preformatted contents of the single cell of 
# the table.
#--------------------------------------------------------
def HTMLBox(mylabel, mytext, bgcolor='#EEE'):

    # Print label and open HTML table
    html  = ''
    html += '<font size="-1"><i>' + mylabel + '</i></font>\n'
    html += '<table><tr><td><div style="border:1px solid black; background-color:'+bgcolor+'">\n' # This just gives a border around outside of table
    html += '<table border="0" bgcolor="'+bgcolor+'" cellpadding="5" cellspacing="2">\n' # Actual table

    # Print content
    html += '<TR><TD><pre>\n' + mytext + '</pre></TD></TR>\n';

    # Close HTML table
    html += '</table>\n'  # actual table
    html += '</div></td></tr></table>\n'  # Border around table
    
    return html



def main():
    pp = pprint.PrettyPrinter(indent=4)

    # Defaults
    OUTPUT_FILENAME = "out.root"
    #RCDB_QUERY = "@is_production and @status_approved"
    RCDB_QUERY = "@is_2018production"
    SRC_VARIATION = "calib"
    DEST_VARIATION = "default"
    BEGIN_RUN = 1
    END_RUN = 10000000
    VERBOSE = 2
    DUMMY_RUN = False
    FORCE_COMMIT = False
    MAX_RUN = ccdb.INFINITE_RUN

    # Define command line options
    parser = OptionParser(usage = "dump_timeseries.py ccdb_tablename")
    #parser.add_option("-T","--table_file", dest="table_file", 
    #                  help="File of CCDB tables to copy")
    parser.add_option("-R","--run_number", dest="run_number", 
                      help="Run number to process")
    parser.add_option("-F","--run_file", dest="run_file", 
                      help="File of runs to look at")
    parser.add_option("-b","--begin-run", dest="begin_run",
                     help="Starting run for output")
    parser.add_option("-e","--end-run", dest="end_run",
                     help="Ending run for output")
    parser.add_option("-m","--max-run", dest="max_run",
                     help="Max run to apply constants for")
    parser.add_option("-D","--dest_variation", dest="dest_variation", 
                      help="Desitination CCDB variation to use")
    parser.add_option("-S","--src_variation", dest="src_variation", 
                      help="Source CCDB variation to use")
    parser.add_option("-Y","--dummy-run", dest="dummy_run", action="store_true",
                      help="Do everything but actually committing changes to the CCDB")
    parser.add_option("-L","--logentry", dest="logentry", 
                      help="File to write elogbook entry.")
    parser.add_option("-M","--mask_file", dest="mask_file", 
                      help="File containing channels to mask.")
    parser.add_option("-f","--force", dest="force_commit", action="store_true", 
                      help="Copy all specified tables.")

    (options, args) = parser.parse_args(sys.argv)

    if(len(args) < 2):
        parser.print_help()
        sys.exit(0)

    CCDB_TABLES = []
    CCDB_TOLERANCES = {}
    with open(args[1]) as f:
        for line in f:
            if len(line.strip()) == 0:
                continue
            if line.strip()[0] == '#':
                continue
            try:
                tokens = line.strip().split()
                CCDB_TABLES.append(tokens[0])
                CCDB_TOLERANCES[tokens[0]] = float(tokens[1])
            except:
                print "Ignoring line: "+line.strip()

    if options.dest_variation:
        DEST_VARIATION = options.dest_variation
    if options.src_variation:
        SRC_VARIATION = options.src_variation
    if options.begin_run:
        BEGIN_RUN = options.begin_run
    if options.end_run:
        END_RUN = options.end_run
    if options.max_run:
        MAX_RUN = options.max_run
    if options.dummy_run:
        DUMMY_RUN = True
    LOGENTRY = None
    if options.logentry:
        LOGENTRY = options.logentry
    if options.force_commit:
        FORCE_COMMIT = options.force_commit
    CHANNEL_MASKS = None
    if options.mask_file:
        CHANNEL_MASKS = {}
        config =  ConfigParser.ConfigParser()
        config.read(options.mask_file)
        #pp.pprint(config.sections())
        #pp.pprint(config.get(config.sections()[0], "mask"))
        for section in config.sections():
            CHANNEL_MASKS[section] = []
            for pair in config.get(config.sections()[0], "mask").split(' '):
                (row,col) = pair.split(',')
                CHANNEL_MASKS[section].append( (int(row),int(col)) )
        #pp.pprint(CHANNEL_MASKS)

    if VERBOSE>0:
        print "CCDB_TABLES:"
        pp.pprint(CCDB_TABLES)
        print "CCDB_TOLERANCES:"
        pp.pprint(CCDB_TOLERANCES)

    # Load CCDB
    ccdb_conn = LoadCCDB()

    # get run list
    runs = None
    if options.run_number:
        runs = [ int(options.run_number) ]
    elif options.run_file:
        runs = []
        with open(options.run_file) as f:
            for line in f:
                try:
                    runs.append(int(line.strip()))
                except:
                    print "Ignoring line: "+line.strip()
    else:
        # Load RCDB
        rcdb_conn = None
        try:
            rcdb_conn = rcdb.RCDBProvider("mysql://rcdb@hallddb.jlab.org/rcdb")
            runs = [ r.number for r in rcdb_conn.select_runs(RCDB_QUERY,BEGIN_RUN,END_RUN) ]
        except:
            e = sys.exc_info()[0]
            print "Could not connect to RCDB: " + str(e)
    
    if runs is None:
        print "no runs specified!"
        return
    if CCDB_TABLES is None or len(CCDB_TABLES)==0:
        print "no tables specified!"
        return

    if LOGENTRY:
        elogentry = open(LOGENTRY, "w")

    for run in runs:
        if LOGENTRY:
            print>>elogentry, MakeHEADER_HTML(run,DUMMY_RUN)
            print>>elogentry, MakeTOLERANCES_HTML(CCDB_TOLERANCES)
            print>>elogentry, "<h2>Modified Tables</h2>\n"

        print "===Checking run %d==="%run
        for ccdb_table in sorted(CCDB_TABLES):
            if VERBOSE>1:
                print "==checking %s for run %d=="%(ccdb_table,run)
            # get source data
            assignment = ccdb_conn.get_assignment(ccdb_table, run, SRC_VARIATION)
            reference_assignment = ccdb_conn.get_assignment(ccdb_table, run, DEST_VARIATION)
            #reference_assignment = ccdb_conn.get_assignment(ccdb_table, 31000, DEST_VARIATION)
            #pp.pprint(assignment.constant_set.data_table)


            channel_mask=None
            if CHANNEL_MASKS is not None and ccdb_table in CHANNEL_MASKS:
                channel_mask = CHANNEL_MASKS[ccdb_table]
                #print "set mask for " + ccdb_table
                #pp.pprint(channel_mask)

            (success, modified_channels) = check_out_of_tolerance(assignment.constant_set.data_table, reference_assignment.constant_set.data_table, CCDB_TOLERANCES[ccdb_table], verbose=VERBOSE, masks=channel_mask)
            if not success and not FORCE_COMMIT:
                continue
                                      
            print "COPYING ",ccdb_table," ..."
            if LOGENTRY:
                print>>elogentry, MakeCCDBTABLE_HTML(ccdb_table, modified_channels, ccdb=ccdb_conn)
            if VERBOSE>1:
                print "NEW"
                pp.pprint(assignment.constant_set.data_table)
                print "OLD"
                pp.pprint(reference_assignment.constant_set.data_table)
            if DUMMY_RUN:
                continue

            # add to destination
            ccdb_conn.create_assignment(
                data=assignment.constant_set.data_table,
                path=ccdb_table,
                variation_name=DEST_VARIATION,
                min_run=run,
                #max_run=MAX_RUN,
                max_run=ccdb.INFINITE_RUN,
                comment="Copied from variation \'%s\'"%ccdb_table)


            # HANDLE SOME SPECIAL CASES
            if ccdb_table == "/PHOTON_BEAM/RF/time_offset":
                ## if the time offsets changed, then we should update the variance as well
                ccdb_table = "/PHOTON_BEAM/RF/time_offset_var"
                assignment = ccdb_conn.get_assignment(ccdb_table, run, SRC_VARIATION)
                ccdb_conn.create_assignment(
                    data=assignment.constant_set.data_table,
                    path=ccdb_table,
                    variation_name=DEST_VARIATION,
                    min_run=run,
                    #max_run=run,
                    max_run=ccdb.INFINITE_RUN,
                    comment="Copied from variation \'%s\'"%ccdb_table)

        #print "===%d==="%run
        #pp.pprint(assignment.constant_set.data_table)

    if LOGENTRY:
        print>>elogentry, "<h3>Other Tables Updated for Run-dependent Calibrations</h3>\n"
        with open("updated_tables.txt") as f:
            for line in f:
                print>>elogentry, line.strip()+"<br>\n"
        elogentry.close()
    

## main function 
if __name__ == "__main__":
    main()
